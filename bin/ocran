#!/usr/bin/env ruby
# -*- ruby -*-
# encoding: UTF-8
require "pathname"

module Ocran
  # Match the load path against standard library, site_ruby, and vendor_ruby paths
  # This regular expression matches:
  # - /ruby/3.0.0/
  # - /ruby/site_ruby/3.0.0/
  # - /ruby/vendor_ruby/3.0.0/
  RUBY_LIBRARY_PATH_REGEX = %r{/(ruby/(?:site_ruby/|vendor_ruby/)?\d+\.\d+\.\d+)/?$}i

  # Alias for the temporary directory where files are extracted.
  TEMPDIR_ROOT = Pathname.new("|")
  # Directory for source files in temporary directory.
  SRCDIR = Pathname.new("src")
  # Directory for Ruby binaries in temporary directory.
  BINDIR = Pathname.new("bin")
  # Directory for GEMHOME files in temporary directory.
  GEMHOMEDIR = Pathname.new("gemhome")
  # Directory for Ruby library in temporary directory.
  LIBDIR = Pathname("lib")

  def self.quiet? = @option.quiet?

  def self.verbose? = @option.verbose?

  def self.warn? = @option.warn?

  def Ocran.msg(s)
    puts "=== #{s}" unless Ocran.quiet?
  end

  def Ocran.verbose_msg(s)
    puts s if Ocran.verbose?
  end

  def Ocran.warn(s)
    msg "WARNING: #{s}" if Ocran.warn?
  end

  def Ocran.fatal_error(s)
    puts "ERROR: #{s}"
    exit 1
  end

  def self.script = @option.script

  def self.ruby_executable
    @ruby_executable ||= @option.windowed? ? rubyw_exe : ruby_exe
  end

  def self.rubyopt
    @rubyopt ||= @option.rubyopt || ENV["RUBYOPT"] || ""
  end

  def self.run_script? = @option.run_script?

  def Ocran.init
    load File.expand_path("../lib/ocran/refine_pathname.rb", __dir__)
    ::Pathname.prepend(RefinePathname)

    load File.expand_path("../lib/ocran/host_config_helper.rb", __dir__)
    Ocran.extend HostConfigHelper

    load File.expand_path("../lib/ocran/runtime_environment.rb", __dir__)
    @pre_env = RuntimeEnvironment.save
    load File.expand_path("../lib/ocran/option.rb", __dir__)
    @option = Option.new
    @option.parse(ARGV)
    ARGV.replace(@option.argv)
    @ignore_modules = ObjectSpace.each_object(Module).to_a
  rescue RuntimeError => e
    Ocran.fatal_error e.message
  end

  # Force loading autoloaded constants. Searches through all modules
  # (and hence classes), and checks their constants for autoloaded
  # ones, then attempts to load them.
  def self.attempt_load_autoload(ignore_modules = [])
    checked_modules = ignore_modules.inject({}) { |h, mod| h[mod] = true; h }
    loop do
      modules_count = ObjectSpace.each_object(Module).count do |mod|
        next if checked_modules.include?(mod)
        mod.constants.each do |const|
          next unless mod.autoload?(const)
          Ocran.msg "Attempting to trigger autoload of #{mod}::#{const}"
          begin
            mod.const_get(const)
          rescue NameError
            Ocran.warn "#{mod}::#{const} was defined autoloadable, but caused NameError"
          rescue LoadError
            Ocran.warn "#{mod}::#{const} was not loadable"
          end
        end
        checked_modules[mod] = true
      end
      break if modules_count == 0
    end
  end

  # Resolves the common root directory prefix from an array of absolute paths.
  # This method iterates over each file path, checking if they have a subpath
  # that matches a given execution prefix.
  def self.resolve_root_prefix(files)
    files.inject(files.first.dirname) do |current_root, file|
      next current_root if file.subpath?(exec_prefix)

      current_root.ascend.find do |candidate_root|
        path_from_root = file.relative_path_from(candidate_root)
      rescue ArgumentError
        raise "No common directory contains all specified files"
      else
        path_from_root.each_filename.first != ".."
      end
    end
  end

  def self.gem_inclusion_set(spec_name)
    include = [:loaded, :files]
    @option.gem_options.each do |negate, option, list|
      next unless list.nil? || list.include?(spec_name)

      case option
      when :minimal
        include = [:loaded]
      when :guess
        include = [:loaded, :files]
      when :all
        include = [:scripts, :files]
      when :full
        include = [:scripts, :files, :extras]
      when :spec
        include = [:spec]
      when :scripts, :files, :extras
        if negate
          include.delete(option)
        else
          include.push(option)
        end
      else
        raise "Invalid Gem content detection option: #{option}"
      end
    end
    include.uniq!
    include
  end

  def self.scanning_gemfile(gemfile_path)
    # Ensure the necessary libraries are loaded to scan the Gemfile.
    # This is particularly useful in custom-built Ruby environments or
    # where certain libraries might be excluded.
    %w[rubygems bundler].each do |lib|
      require lib
    rescue LoadError
      raise "Couldn't scan Gemfile, unable to load #{lib}"
    end

    ENV["BUNDLE_GEMFILE"] = gemfile_path.to_s
    # Bundler.load.specs includes the spec for Bundler itself
    Bundler.load.specs.to_a
  end

  # Fall back to gem detection
  def self.detect_gems_from(features)
    require_relative "../lib/ocran/gem_spec_queryable"

    features.inject([]) do |gems, feature|
      if gems.any? { |spec| feature.subpath?(spec.gem_dir) }
        # Skip if found in known Gem dir
      elsif (spec = GemSpecQueryable.find_spec(feature))
        gems << spec
      else
        Ocran.warn "Failed to load gemspec for #{feature}"
      end

      gems
    end
  end

  # For RubyInstaller environments supporting Ruby 2.4 and above,
  # this method checks for the existence of a required manifest file
  def self.ruby_builtin_manifest
    manifest_path = exec_prefix / "bin/ruby_builtin_dlls/ruby_builtin_dlls.manifest"
    manifest_path.exist? ? manifest_path : nil
  end

  def self.detect_dlls
    require_relative "../lib/ocran/library_detector"
    LibraryDetector.loaded_dlls.map { |path| Pathname.new(path).cleanpath }
  end

  def Ocran.build_exe
    post_env = RuntimeEnvironment.save

    ENV.replace(@pre_env.env)

    # If the script was run and autoload is enabled, attempt to autoload libraries.
    if @option.force_autoload?
      attempt_load_autoload(@ignore_modules)
    end

    # Store the currently loaded files (before we require rbconfig for
    # our own use).
    features = $LOADED_FEATURES.map { |feature| Pathname(feature) }
    # NOTE: From this point, $LOADED_FEATURES has been captured, so it is now
    # safe to call require_relative.

    # Since https://github.com/rubygems/rubygems/commit/cad4cf16cf8fcc637d9da643ef97cf0be2ed63cb
    # rubygems/core_ext/kernel_require.rb is evaled and thus missing in $LOADED_FEATURES, so we can't find it and need to add it manually
    features.push(Pathname("rubygems/core_ext/kernel_require.rb"))

    # Convert all relative paths to absolute paths before building.
    # NOTE: In the future, different strategies may be needed before and after script execution.
    features = features.filter_map do |feature|
      if feature.absolute?
        feature
      elsif (load_path = post_env.find_load_path(feature))
        feature.expand_path(post_env.expand_path(load_path))
      else
        # This message occurs when paths for core library files (e.g., enumerator.so,
        # rational.so, complex.so, fiber.so, thread.rb, ruby2_keywords.rb) are not
        # found. These are integral to Ruby's standard libraries or extensions and
        # may not be located via normal load path searches, especially in RubyInstaller
        # environments.
        Ocran.verbose_msg "Load path not found for #{feature}, skip this feature"
        nil
      end
    end

    # If a Bundler Gemfile was provided, add all gems it specifies
    if @option.gemfile
      Ocran.msg "Scanning Gemfile"
      specs_from_gemfile = Ocran.scanning_gemfile(@option.gemfile)
      specs_from_gemfile.each do |spec|
        Ocran.verbose_msg "From Gemfile, adding gem #{spec.full_name}"
      end
    else
      specs_from_gemfile = []
    end
    # Find gems files and remove them from features
    if defined?(Gem)
      gemfile_gems = specs_from_gemfile.map { |spec| [spec.name, spec] }.to_h
      # Include Gems that are loaded
      loaded_specs = Gem.loaded_specs.values.map { |spec| [spec.name, spec] }.to_h
      # Now, we also detect gems that are not included in Gem.loaded_specs.
      # Therefore, we look for any loaded file from a gem path.
      detected_gems = detect_gems_from(features).map { |spec| [spec.name, spec] }.to_h
      # Prioritize the spec detected from Gemfile.
      gemspecs = detected_gems.merge(loaded_specs).merge(gemfile_gems).values
    else
      gemspecs = []
    end

    direction = proc do |builder|
      Ocran.msg "Building #{@option.output_executable}"
      require_relative "../lib/ocran/builder_ops_logger"
      builder.extend(BuilderOpsLogger) if Ocran.verbose?
      require_relative "../lib/ocran/build_helper"
      builder.extend(BuildHelper)

      # Add the ruby executable and DLL
      Ocran.msg "Adding ruby executable #{Ocran.ruby_executable}"
      builder.copy_to_bin(bindir / Ocran.ruby_executable, Ocran.ruby_executable)
      if libruby_so
        builder.copy_to_bin(bindir / libruby_so, libruby_so)
      end

      # Add detected DLLs
      if @option.auto_detect_dlls?
        Ocran.detect_dlls.each do |dll|
          next unless dll.subpath?(exec_prefix) && dll.extname?(".dll") && dll.basename != libruby_so

          Ocran.msg "Adding detected DLL #{dll}"
          if dll.subpath?(exec_prefix)
            builder.duplicate_to_exec_prefix(dll)
          else
            builder.copy_to_bin(dll, dll.basename)
          end
        end
      end

      # Add external manifest files
      [Ocran.ruby_builtin_manifest].compact.each do |manifest|
        Ocran.msg "Adding external manifest #{manifest}"
        builder.duplicate_to_exec_prefix(manifest)
      end

      # Add extra DLLs specified on the command line
      @option.extra_dlls.each do |dll|
        Ocran.msg "Adding supplied DLL #{dll}"
        builder.copy_to_bin(bindir / dll, dll)
      end

      # Searches for features that are loaded from gems, then produces a
      # list of files included in those gems' manifests. Also returns a
      # list of original features that caused those gems to be included.
      gem_files = gemspecs.flat_map do |spec|
        spec_file = Pathname(spec.loaded_from)
        # From Ruby 3.2 onwards, launching Ruby with bundle exec causes
        # Bundler's loaded_from to point to the root directory of the
        # bundler gem, not returning the path to gemspec files. Here, we
        # are only collecting gemspec files.
        unless spec_file.file?
          Ocran.warn "Gem #{spec.full_name} root folder was not found, skipping"
          next []
        end

        # Add gemspec files
        if spec_file.subpath?(exec_prefix)
          builder.duplicate_to_exec_prefix(spec_file)
        elsif (gem_path = GemSpecQueryable.find_gem_path(spec_file))
          builder.duplicate_to_gem_home(spec_file, gem_path)
        else
          raise "Gem spec #{spec_file} does not exist in the Ruby installation. Don't know where to put it."
        end

        # Determine which set of files to include for this particular gem
        include = Ocran.gem_inclusion_set(spec.name)
        Ocran.msg "Detected gem #{spec.full_name} (#{include.join(", ")})"

        require_relative "../lib/ocran/gem_spec_queryable"
        spec.extend(GemSpecQueryable)

        actual_files = spec.find_gem_files(include, features)
        Ocran.msg "\t#{actual_files.size} files, #{actual_files.sum(0, &:size)} bytes"

        # Decide where to put gem files, either the system gem folder, or
        # GEMHOME.
        actual_files.each do |gemfile|
          if gemfile.subpath?(exec_prefix)
            builder.duplicate_to_exec_prefix(gemfile)
          elsif (gem_path = GemSpecQueryable.find_gem_path(gemfile))
            builder.duplicate_to_gem_home(gemfile, gem_path)
          else
            raise "Don't know where to put gemfile #{gemfile}"
          end
        end

        actual_files
      end
      gem_files.uniq!

      features -= gem_files

      # If requested, add all ruby standard libraries
      if @option.add_all_core?
        Ocran.msg "Will include all ruby core libraries"
        @pre_env.load_path.each do |load_path|
          path = Pathname.new(load_path)
          # Match the load path against standard library, site_ruby, and vendor_ruby paths
          path.to_posix.match(RUBY_LIBRARY_PATH_REGEX) do |m|
            subdir = m[1]
            path.find.each do |src|
              next if src.directory?
              builder.copy_to_lib(src, Pathname(subdir) / src.relative_path_from(path))
            end
          end
        end
      end

      # Include encoding support files
      if @option.add_all_encoding?
        post_env.load_path.each do |load_path|
          load_path = Pathname(post_env.expand_path(load_path))
          next unless load_path.subpath?(exec_prefix)

          enc_dir = load_path / "enc"
          next unless enc_dir.directory?

          enc_files = enc_dir.find.select { |path| path.file? && path.extname?(".so") }
          Ocran.msg "Including #{enc_files.size} encoding support files (#{enc_files.sum(0, &:size)} bytes, use --no-enc to exclude)"
          enc_files.each do |path|
            builder.duplicate_to_exec_prefix(path)
          end
        end
      else
        Ocran.msg "Not including encoding support files"
      end

      # Workaround: RubyInstaller cannot find the msys folder if ../msys64/usr/bin/msys-2.0.dll is not present (since RubyInstaller-2.4.1 rubyinstaller 2 issue 23)
      # Add an empty file to /msys64/usr/bin/msys-2.0.dll if the dll was not required otherwise
      builder.touch('msys64/usr/bin/msys-2.0.dll')

      # Find the source root and adjust paths
      source_files = @option.source_files.dup
      src_prefix = resolve_root_prefix(source_files)

      # Find features and decide where to put them in the temporary
      # directory layout.
      src_load_path = []
      # Add loaded libraries (features, gems)
      Ocran.msg "Adding library files"
      added_load_paths = (post_env.load_path - @pre_env.load_path).map { |load_path| Pathname(post_env.expand_path(load_path)) }
      pre_working_directory = Pathname(@pre_env.pwd)
      working_directory = Pathname(post_env.pwd)
      features.each do |feature|
        load_path = post_env.find_load_path(feature)
        if load_path.nil?
          source_files << feature
          next
        end
        abs_load_path = Pathname(post_env.expand_path(load_path))
        if abs_load_path == pre_working_directory
          source_files << feature
        elsif feature.subpath?(exec_prefix)
          # Features found in the Ruby installation are put in the
          # temporary Ruby installation.
          builder.duplicate_to_exec_prefix(feature)
        elsif (gem_path = GemSpecQueryable.find_gem_path(feature))
          # Features found in any other Gem path (e.g. ~/.gems) is put
          # in a special 'gemhome' folder.
          builder.duplicate_to_gem_home(feature, gem_path)
        elsif feature.subpath?(src_prefix) || abs_load_path == working_directory
          # Any feature found inside the src_prefix automatically gets
          # added as a source file (to go in 'src').
          source_files << feature
          # Add the load path unless it was added by the script while
          # running (or we assume that the script can also set it up
          # correctly when running from the resulting executable).
          src_load_path << abs_load_path unless added_load_paths.include?(abs_load_path)
        elsif added_load_paths.include?(abs_load_path)
          # Any feature that exist in a load path added by the script
          # itself is added as a file to go into the 'src' (src_prefix
          # will be adjusted below to point to the common parent).
          source_files << feature
        else
          # All other feature that can not be resolved go in the the
          # Ruby sitelibdir. This is automatically in the load path
          # when Ruby starts.
          inst_sitelibdir = sitelibdir.relative_path_from(exec_prefix)
          builder.cp(feature, inst_sitelibdir / feature.relative_path_from(abs_load_path))
        end
      end

      # Recompute the src_prefix. Files may have been added implicitly
      # while scanning through features.
      inst_src_prefix = resolve_root_prefix(source_files)

      # Add explicitly mentioned files
      Ocran.msg "Adding user-supplied source files"
      target_script = nil
      source_files.each do |file|
        if file.subpath?(exec_prefix)
          target = file.relative_path_from(exec_prefix)
        elsif file.subpath?(inst_src_prefix)
          target = SRCDIR / file.relative_path_from(inst_src_prefix)
        else
          target = SRCDIR / file.basename
        end

        target_script ||= target

        if file.directory?
          builder.mkdir(target)
        elsif file.exist?
          builder.cp(file, target)
        else
          raise "The file does not exist (#{file})"
        end
      end

      # Set environment variable

      # FIXME: Remove the absolute path to bundler/setup from RUBYOPT
      # This is a temporary measure to ensure compatibility with self-extracting executables
      # built in a bundle exec environment, particularly for Ruby 3.2 and later where
      # absolute paths are included in RUBYOPT.
      # In the future, we plan to implement a more appropriate solution.
      builder.export("RUBYOPT", Ocran.rubyopt.gsub(%r(-r#{Regexp.escape(RbConfig::TOPDIR)}(/.*/bundler/setup)), ""))
      # Add the load path that are required with the correct path after
      # src_prefix was adjusted.
      load_path = src_load_path.map { |path| SRCDIR / path.relative_path_from(inst_src_prefix) }.uniq
      builder.set_env_path("RUBYLIB", *load_path)
      builder.set_env_path("GEM_PATH", GEMHOMEDIR)

      # Add the opcode to launch the script
      installed_ruby_exe = BINDIR / Ocran.ruby_executable
      builder.exec(installed_ruby_exe, target_script, *@option.argv)
    end

    if @option.use_inno_setup?
      require_relative "../lib/ocran/inno_setup_builder"
      InnoSetupBuilder.new(@option.output_executable,
                           @option.inno_setup_script,
                           chdir_before: @option.chdir_before?,
                           icon_path: @option.icon_filename,
                           title: @option.output_executable.basename.sub_ext(""),
                           &direction)
      Ocran.msg "Finished building installer file"
    else
      require_relative "../lib/ocran/stub_builder"
      if @option.enable_debug_mode?
        Ocran.msg("Enabling debug mode in executable")
      end
      StubBuilder.new(@option.output_executable,
                      chdir_before: @option.chdir_before?,
                      debug_extract: @option.enable_debug_extract?,
                      debug_mode: @option.enable_debug_mode?,
                      enable_compression: @option.enable_compression?,
                      gui_mode: @option.windowed?,
                      icon_path: @option.icon_filename,
                      &direction) => builder
      Ocran.msg "Finished building #{@option.output_executable} (#{@option.output_executable.size} bytes)"
      Ocran.msg "After decompression, the data will expand to #{builder.data_size} bytes."
    end
  rescue RuntimeError => e
    Ocran.fatal_error e.message
  end
end # module Ocran

if File.basename(__FILE__) == File.basename($PROGRAM_NAME)
  Ocran.init

  at_exit do
    if $!.nil? or $!.kind_of?(SystemExit)
      Ocran.build_exe
      exit 0
    end
  end

  if Ocran.run_script?
    Ocran.msg "Loading script to check dependencies"
    $PROGRAM_NAME = Ocran.script.to_s
    load Ocran.script
  end
end

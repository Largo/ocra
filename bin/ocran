#!/usr/bin/env ruby
# encoding: UTF-8
require "pathname"

module Ocran
  # Alias for the temporary directory where files are extracted.
  EXTRACT_ROOT = Pathname.new("|")
  # Directory for source files in temporary directory.
  SRCDIR = Pathname.new("src")
  # Directory for Ruby binaries in temporary directory.
  BINDIR = Pathname.new("bin")
  # Directory for gem files in temporary directory.
  GEMDIR = Pathname.new("gems")
  # Directory for Ruby library in temporary directory.
  LIBDIR = Pathname("lib")

  def self.quiet? = @option.quiet?

  def self.verbose? = @option.verbose?

  def self.warning? = @option.warning?

  def Ocran.fatal_error(s)
    error s
    exit 1
  end

  def self.script = @option.script

  def self.rubyopt = @rubyopt

  def self.run_script? = @option.run_script?

  def Ocran.init
    load File.expand_path("../lib/ocran/command_output.rb", __dir__)
    extend CommandOutput

    load File.expand_path("../lib/ocran/runtime_environment.rb", __dir__)
    @pre_env = RuntimeEnvironment.save

    load File.expand_path("../lib/ocran/option.rb", __dir__)
    @option = Option.new.tap do |opt|
      opt.parse(ARGV)
    rescue RuntimeError => e
      # Capture RuntimeError during parsing and display an appropriate
      # error message to the user. This error usually occurs from invalid
      # option arguments.
      Ocran.fatal_error e.message
    else
      # Update ARGV with the parsed command line arguments to pass to
      # the user's script. This ensures the script executes based on
      # the user-specified arguments.
      ARGV.replace(opt.argv)
    end

    # Initializes @rubyopt with the user-intended RUBYOPT environment variable.
    # This ensures that RUBYOPT matches the user's initial settings before any
    # modifications that may occur during script execution.
    @rubyopt = @option.rubyopt || ENV["RUBYOPT"] || ""

    # FIXME: Remove the absolute path to bundler/setup from RUBYOPT
    # This is a temporary measure to ensure compatibility with self-extracting executables
    # built in a bundle exec environment, particularly for Ruby 3.2 and later where
    # absolute paths are included in RUBYOPT.
    # In the future, we plan to implement a more appropriate solution.
    @rubyopt = @rubyopt.gsub(%r(-r#{Regexp.escape(RbConfig::TOPDIR)}(/.*/bundler/setup)), "")

    @ignore_modules = ObjectSpace.each_object(Module).to_a
  end

  # Force loading autoloaded constants. Searches through all modules
  # (and hence classes), and checks their constants for autoloaded
  # ones, then attempts to load them.
  def self.attempt_load_autoload(ignore_modules = [])
    checked_modules = ignore_modules.inject({}) { |h, mod| h[mod] = true; h }
    while ObjectSpace.each_object(Module).count { |mod|
      next if checked_modules.include?(mod)
      mod.constants.each do |const|
        next unless mod.autoload?(const)
        say "Attempting to trigger autoload of #{mod}::#{const}"
        begin
          mod.const_get(const)
        rescue ScriptError, StandardError => e
          # Some autoload constants may throw exceptions beyond the expected
          # errors. This includes issues dependent on the system or execution
          # environment, so it is preferable to ignore exceptions other than
          # critical errors.
          warning "#{mod}::#{const} loading failed: #{e.message}"
        end
      end
      checked_modules[mod] = true
    }.nonzero?
      # Loops until all constants have been checked.
    end
  end

  def self.build_inno_setup_installer(&direction)
    require_relative "../lib/ocran/inno_setup_script_builder"
    iss_builder = InnoSetupScriptBuilder.new(@option.inno_setup_script)

    require_relative "../lib/ocran/launcher_batch_builder"
    launcher_builder = LauncherBatchBuilder.new(
      chdir_before: @option.chdir_before?,
      title: @option.output_executable.basename.sub_ext("")
    )

    require_relative "../lib/ocran/build_facade"
    builder = BuildFacade.new(iss_builder, launcher_builder)

    if @option.icon_filename
      builder.cp(@option.icon_filename, File.basename(@option.icon_filename))
    end

    direction.call(builder)

    say "Build launcher batch file"
    launcher_path = launcher_builder.build
    verbose File.read(launcher_path)
    builder.cp(launcher_path, "launcher.bat")

    say "Build inno setup script file"
    iss_path = iss_builder.build
    verbose File.read(iss_path)

    say "Running Inno Setup Command-Line compiler (ISCC)"
    iss_builder.compile(verbose: Ocran.verbose?)

    say "Finished building installer file"
  end

  def self.build_stab_exe(&direction)
    require_relative "../lib/ocran/stub_builder"

    if @option.enable_debug_mode?
      say "Enabling debug mode in executable"
    end

    StubBuilder.new(@option.output_executable,
                    chdir_before: @option.chdir_before?,
                    debug_extract: @option.enable_debug_extract?,
                    debug_mode: @option.enable_debug_mode?,
                    enable_compression: @option.enable_compression?,
                    gui_mode: @option.windowed?,
                    icon_path: @option.icon_filename,
                    &direction) => builder
    say "Finished building #{@option.output_executable} (#{@option.output_executable.size} bytes)"
    say "After decompression, the data will expand to #{builder.data_size} bytes."
  end

  def self.build
    # If the script was run and autoload is enabled, attempt to autoload libraries.
    if @option.force_autoload?
      attempt_load_autoload(@ignore_modules)
    end

    @post_env = RuntimeEnvironment.save
    # NOTE: From this point, $LOADED_FEATURES has been captured, so it is now
    # safe to call require_relative.

    ENV.replace(@pre_env.env)

    # It might be useful to reset the current directory to the point where the
    # command was launched, especially when implementing the builder object.
    Dir.chdir(@pre_env.pwd)

    require_relative "../lib/ocran/direction"
    direction = Direction.new(@post_env, @pre_env, @option)

    if @option.use_inno_setup?
      build_inno_setup_installer(&direction)
    else
      build_stab_exe(&direction)
    end
  rescue RuntimeError => e
    Ocran.fatal_error e.message
  end
end # module Ocran

if File.basename(__FILE__) == File.basename($PROGRAM_NAME)
  Ocran.init

  at_exit do
    if $!.nil? or $!.kind_of?(SystemExit)
      Ocran.build
      exit 0
    end
  end

  if Ocran.run_script?
    Ocran.say "Loading script to check dependencies"
    $PROGRAM_NAME = Ocran.script.to_s
    load Ocran.script
  end
end
